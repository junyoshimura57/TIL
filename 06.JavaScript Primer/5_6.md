## JavaScript Primer(型変換～第1部終了まで）
- 暗黙的な型変換について  
  JSの場合は、`1 + true`を計算すと`true`が`1`に変換されて、2がエラーなく計算される。  
  また`1 + "2"`を計算すると`"1" + "2"`に暗黙的な型変換が行わるので、12が計算される。  
  上記のようなことは予期せぬ結果を生んでしまうので、明示的な型変換をする必要がある！！

  - 任意の値 -> 真偽値  
  `Boolean`コンストラクタを使用する。

  - 数値 -> 文字列  
  `String`コンストラクタを使用する。

  - 文字列 -> 数値  
  `Number`コンストラクタを使用する。

  - NaN(Not a Number)の特徴  
  1. 計算の途中で値がNaNになると、最終的な結果もNaNになる。
  2. NaNはNumber型の一種である。
  3. 自分自身と一致しない。  
  上記の特徴があるので、Number型の値を受付、渡すようにする必要がある！！


- デフォルト引数について  
  仮引数に対応する引数が渡されていない場合にデフォルトで代入することができる。  
  ex)function 関数名(仮引数1 = デフォルト値1, 仮引数2 = デフォルト値2)


- 可変長引数について  
可変長引数は`...restArgs`（restArgsは配列名）のような引数をまとめた配列を仮引数に定義をする必要がある。


- アロー関数の特徴
アロー関数では、仮引数と処理が一つの場合、return、()を省略することができる。  
※関数の表現方法が色々ありすぎて複雑だ...


- メソッドの書き方について  
短縮系である`メソッド名(){ /*メソッドの処理*/ }`と書くことができる。（呼び出し方法は、`オブジェクト名.メソッド名()`）


- 文と式について  
変数、関数呼び出しなど式、処理する1ステップが文。（ブロックで終わらない文にはセミコロンを文末につける必要がある）


- forEachメソッドについて
```
const array = [1, 2, 3];
array.forEach(currentValue => {
    console.log(currentValue);
});
// 1
// 2
// 3
```
【上記の考え方】
1. `array.forEach`の引数に`currentValue => {console.log(currentValue);}`が入っている。（コールバック関数）
2. `currentValue => {console.log(currentValue);}`は、アロー関数の省略的な書き方である①return命令の省略、②return命令の省略が使われている。（省略については以下を参照）
> https://qiita.com/may88seiji/items/4a49c7c78b55d75d693b  
3. `forEach`メソッドにより`currentValue`に配列の中身が順番に入っていく。  


- オブジェクトの作成方法
オブジェクトリテラルを使用する。ex.`const obj = {// キー: 値 "key": "value"};`


- 配列のlengthプロパティについて  
`配列名.length`で配列の長さを求めることができる。


- 配列に対するメソッドについて  
配列にはインデックスを取得したり、指定範囲の要素を取得したい配列に指定した要素が含まれているか確認するメソッドが用意されている。


- ラッパーオブジェクトについて  
Stringなどのプリミティブ型には、それぞれ対応するオブジェクトがある。  
StringオブジェクトをnewすることでStringオブジェクトのインスタンスを作れる。（どこで使うんだろう？？）

-  letとvarの違い
varの場合は、変数の宣言がスコープ外の場合でもエラーにならず参照できる。
※これは意図せぬ動きも多いため、基本はletを使用するのがいいらしい。


- Mapについて  
マップとはキー、値の組み合わせからな抽象データ。  
`const map = new Map([["key1", "value1"], ["key2", "value2"]]);`※定義方法  
`console.log(map.get("key")); // => "value1"`※取り出し方法  

- MapとObjectの違いについて  
Objectの弱点は以下がある。
1. キーとして使えるのは文字列かSymbolに限られる
2. Objectをマップとして使うと、そのプロパティと同じ名前のキーを使おうとしたときに問題となる。
